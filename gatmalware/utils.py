
import json
import numpy as np
from matplotlib import pyplot as plt
from scipy.stats import linregress
   

def load_dict(filepath: str = 'config/args.json') -> dict:
    """_summary_

    Args:
        filepath (str, optional): _description_. Defaults to 'config/args.json'.

    Returns:
        dict: _description_
    """
    with open(filepath, 'r') as fp:
        return json.load(fp)



def mass_fd(x, k=5, skip=0, norm=2, gyration=True, ratios=False, verbose=False):
    
    # remove zero values
    x = x[~np.all(x == 0, axis=1)]
    
    # mean along each axis
    centroid = x.mean(axis=0) 

    # find distances and sort by proximity to centroid
    dist = np.power(np.sum(np.abs(x - centroid) ** norm, axis=1), 1. / norm)
    dist_idx_sorted = np.argsort(dist)

    # split distances array into k partitions
    N = np.array_split(dist_idx_sorted, k)
    # points for log-log plot
    Rg = []
    Nk = []

    # loop through scales
    for i in range(k):

        # concatenates sucessive nodes away from centroid (e.g Nk_1, Nk_1 + Nk_2)
        Nj = x[np.concatenate(N[:i+1])]

        # compute the centroid for each k if using ROG
        if gyration:
            centroid = Nj.mean(axis=0)
    
        # compute the std. dev in all d dimensions
        Rg.append(np.power(np.sum(np.abs(Nj - centroid) ** norm) / len(Nj), 1. / norm))
        # append the number of nodes considered
        Nk.append(Nj.shape[0])

    # vanilla implementation, just used the raw std. devs.
    if not ratios:
        log_Rg = np.log(Rg)[:-skip] if skip != 0 else np.log(Rg)
        log_Nk = np.log(Nk)[:-skip] if skip != 0 else np.log(Nk)
        
    # this implementation looks at the ratios of the std. devs. Doesn't work well
    else:
        log_Rg = [np.log(Rg[i] / Rg[i-1]) for i in range(1, len(Rg) - skip)]
        log_Nk = [np.log(Nk[i] / Nk[i-1]) for i in range(1, len(Nk) - skip)]

    # determine the slope as D
    D, *_ = linregress(log_Nk, log_Rg)
    
    # if needed plot the log-log plot and additional metrics
    if verbose:
        print(f"{Rg=}, {Nk=}")
        print(f"{log_Rg=}, {log_Nk=}")
        
        plt.scatter(x[:, 0], x[:, 1])
        plt.show()
        plt.scatter(log_Nk, log_Rg)
        plt.xlabel(f'log(Nk)', fontsize=15)
        plt.ylabel(f'log(Rg)', fontsize=15)

        plt.grid(True)
        plt.tight_layout()
        plt.show()
        
    return D